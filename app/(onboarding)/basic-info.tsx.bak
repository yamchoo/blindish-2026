/**
 * Basic Info Screen
 * Collects name, age, gender, and looking for
 */

import React, { useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, Alert, Platform } from 'react-native';
import { router } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import DateTimePicker from '@react-native-community/datetimepicker';
import { Button, Input, Card, AnimatedBackground } from '@/components/ui';
import { useAuth } from '@/features/auth';
import { useAuthStore } from '@/stores/authStore';
import { supabase, withRetryAndFallback, directUpsert } from '@/lib/supabase';
import { getAuthToken } from '@/lib/supabase/session-helper';
import { Colors } from '@/lib/constants/colors';
import { Typography, Spacing, BorderRadius } from '@/lib/constants/typography';

type Gender = 'male' | 'female' | 'non-binary' | 'other';
type LookingFor = 'male' | 'female' | 'non-binary' | 'everyone';

const GENDER_OPTIONS: { value: Gender; label: string }[] = [
  { value: 'male', label: 'Male' },
  { value: 'female', label: 'Female' },
  { value: 'non-binary', label: 'Non-binary' },
  { value: 'other', label: 'Other' },
];

const LOOKING_FOR_OPTIONS: { value: LookingFor; label: string }[] = [
  { value: 'male', label: 'Men' },
  { value: 'female', label: 'Women' },
  { value: 'non-binary', label: 'Non-binary' },
  { value: 'everyone', label: 'Everyone' },
];

export default function BasicInfoScreen() {
  const { user, refreshProfile } = useAuth();
  const [loading, setLoading] = useState(false);

  const [formData, setFormData] = useState({
    name: '',
    dateOfBirth: null as Date | null,
    gender: '' as Gender | '',
    lookingFor: [] as LookingFor[],
    occupation: '',
  });

  const [showDatePicker, setShowDatePicker] = useState(false);

  const [errors, setErrors] = useState<Record<string, string>>({});

  // Calculate age from date of birth
  const calculateAge = (birthDate: Date): number => {
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();

    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }

    return age;
  };

  // Format date for display
  const formatDate = (date: Date): string => {
    return date.toLocaleDateString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric',
    });
  };

  const validateForm = () => {
    const newErrors: Record<string, string> = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Name is required';
    }

    if (!formData.dateOfBirth) {
      newErrors.dateOfBirth = 'Please select your birthday';
    } else {
      const age = calculateAge(formData.dateOfBirth);
      if (age < 18) {
        newErrors.dateOfBirth = 'You must be at least 18 years old';
      } else if (age > 100) {
        newErrors.dateOfBirth = 'Please enter a valid birthday';
      }
    }

    if (!formData.gender) {
      newErrors.gender = 'Please select your gender';
    }

    if (formData.lookingFor.length === 0) {
      newErrors.lookingFor = 'Please select who you\'re looking for';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleDateChange = (event: any, selectedDate?: Date) => {
    // On Android, the picker closes automatically
    if (Platform.OS === 'android') {
      setShowDatePicker(false);
    }

    if (selectedDate) {
      setFormData(prev => ({ ...prev, dateOfBirth: selectedDate }));
      if (errors.dateOfBirth) {
        setErrors(prev => ({ ...prev, dateOfBirth: '' }));
      }
    }
  };

  const handleContinue = async () => {
    console.log('handleContinue called');

    if (!validateForm()) {
      console.log('Form validation failed');
      return;
    }

    if (!user) {
      console.error('No user found');
      Alert.alert('Error', 'User not found. Please sign in again.');
      return;
    }

    console.log('Starting profile save for user:', user.id);
    setLoading(true);

    // Set operation in progress to prevent navigation redirects
    useAuthStore.getState().setOperationInProgress(true);

    try {

      // Convert lookingFor to gender array (map "everyone" to all genders)
      let lookingForArray: string[] = [];
      if (formData.lookingFor.includes('everyone')) {
        lookingForArray = ['male', 'female', 'non-binary', 'other'];
      } else {
        lookingForArray = formData.lookingFor;
      }

      const calculatedAge = formData.dateOfBirth ? calculateAge(formData.dateOfBirth) : 0;

      console.log('Upserting profile with data:', {
        id: user.id,
        name: formData.name,
        age: calculatedAge,
        dateOfBirth: formData.dateOfBirth,
        gender: formData.gender,
      });

      // Create or update profile with retry/fallback pattern
      console.log('Starting database upsert with retry/fallback...');

      const profileData = {
        id: user.id,
        email: user.email || '',
        name: formData.name.trim(),
        age: calculatedAge,
        date_of_birth: formData.dateOfBirth?.toISOString().split('T')[0],
        gender: formData.gender,
        looking_for: lookingForArray,
        occupation: formData.occupation.trim() || null,
        onboarding_step: 1,
        onboarding_completed: false, // Reset to false when starting onboarding
        updated_at: new Date().toISOString(),
      };

      console.log('Profile data to save:', profileData);

      // Get auth token for fallback operations (from in-memory auth store, no network call)
      const authToken = getAuthToken();

      // Use retry/fallback pattern: try Supabase client first, fall back to direct API if needed
      const { error } = await withRetryAndFallback(
        // Primary operation: Use Supabase client
        () =>
          supabase.from('profiles').upsert(profileData, {
            onConflict: 'id',
          }),
        // Fallback operation: Use direct REST API
        (token) =>
          directUpsert('profiles', profileData, {
            onConflict: 'id',
          }, token),
        undefined,
        authToken
      );

      if (error) {
        console.error('Error updating profile:', error);
        Alert.alert('Error', `Failed to save your information: ${error.message}`);
        return;
      }

      console.log('Profile saved successfully');

      // Refresh profile (non-blocking - continue even if it fails)
      console.log('Refreshing profile...');
      refreshProfile().catch((refreshError) => {
        console.warn('Profile refresh failed, but continuing:', refreshError);
        // The profile will sync on next app load via auth state listener
      });

      // Continue to next step
      console.log('Navigating to lifestyle intro');
      router.push('/(onboarding)/lifestyle-intro');
    } catch (error) {
      console.error('Error in handleContinue:', error);
      Alert.alert('Error', 'Something went wrong. Please try again.');
    } finally {
      console.log('Setting loading to false');
      setLoading(false);
      // Clear operation in progress flag
      useAuthStore.getState().setOperationInProgress(false);
    }
  };

  const toggleLookingFor = (value: LookingFor) => {
    setFormData(prev => {
      const current = prev.lookingFor;
      if (current.includes(value)) {
        return { ...prev, lookingFor: current.filter(v => v !== value) };
      } else {
        return { ...prev, lookingFor: [...current, value] };
      }
    });
    // Clear error when user makes a selection
    if (errors.lookingFor) {
      setErrors(prev => ({ ...prev, lookingFor: '' }));
    }
  };

  return (
    <View style={styles.container}>
      <AnimatedBackground opacity={0.2} speed={0.5} />

      <SafeAreaView style={styles.safeArea} edges={['top', 'bottom']}>
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
        <View style={styles.content}>
          {/* Header */}
          <View style={styles.header}>
            <Text style={styles.title}>Tell Us About You</Text>
            <Text style={styles.subtitle}>
              We'll use this to find your best matches
            </Text>
          </View>

          {/* Form */}
          <View style={styles.form}>
            <Input
              label="Name"
              value={formData.name}
              onChangeText={(text) => {
                setFormData(prev => ({ ...prev, name: text }));
                if (errors.name) setErrors(prev => ({ ...prev, name: '' }));
              }}
              placeholder="Your name"
              error={errors.name}
              required
            />

            {/* Birthday Picker */}
            <View style={styles.fieldGroup}>
              <Text style={styles.label}>
                Birthday <Text style={styles.required}>*</Text>
              </Text>
              <TouchableOpacity
                style={[
                  styles.datePickerButton,
                  errors.dateOfBirth && styles.datePickerButtonError,
                ]}
                onPress={() => setShowDatePicker(true)}
              >
                <Text
                  style={[
                    styles.datePickerText,
                    !formData.dateOfBirth && styles.datePickerPlaceholder,
                  ]}
                >
                  {formData.dateOfBirth ? formatDate(formData.dateOfBirth) : 'Select your birthday'}
                </Text>
                {formData.dateOfBirth && (
                  <Text style={styles.ageDisplay}>
                    Age: {calculateAge(formData.dateOfBirth)}
                  </Text>
                )}
              </TouchableOpacity>
              {errors.dateOfBirth && (
                <Text style={styles.errorText}>{errors.dateOfBirth}</Text>
              )}
            </View>

            {/* Date Picker Modal */}
            {showDatePicker && (
              <DateTimePicker
                value={formData.dateOfBirth || new Date(2000, 0, 1)}
                mode="date"
                display={Platform.OS === 'ios' ? 'spinner' : 'default'}
                onChange={handleDateChange}
                maximumDate={new Date()}
                minimumDate={new Date(1924, 0, 1)}
                {...(Platform.OS === 'ios' && {
                  onPress: () => setShowDatePicker(false),
                })}
              />
            )}

            {/* iOS: Add done button for date picker */}
            {Platform.OS === 'ios' && showDatePicker && (
              <View style={styles.datePickerActions}>
                <Button
                  title="Done"
                  onPress={() => setShowDatePicker(false)}
                  size="sm"
                />
              </View>
            )}

            {/* Gender Selection */}
            <View style={styles.fieldGroup}>
              <Text style={styles.label}>
                Gender <Text style={styles.required}>*</Text>
              </Text>
              <View style={styles.optionsGrid}>
                {GENDER_OPTIONS.map((option) => (
                  <TouchableOpacity
                    key={option.value}
                    style={[
                      styles.optionButton,
                      formData.gender === option.value && styles.optionButtonSelected,
                    ]}
                    onPress={() => {
                      setFormData(prev => ({ ...prev, gender: option.value }));
                      if (errors.gender) setErrors(prev => ({ ...prev, gender: '' }));
                    }}
                  >
                    <Text
                      style={[
                        styles.optionText,
                        formData.gender === option.value && styles.optionTextSelected,
                      ]}
                    >
                      {option.label}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
              {errors.gender && <Text style={styles.errorText}>{errors.gender}</Text>}
            </View>

            {/* Looking For */}
            <View style={styles.fieldGroup}>
              <Text style={styles.label}>
                Looking For <Text style={styles.required}>*</Text>
              </Text>
              <Text style={styles.hint}>You can select multiple</Text>
              <View style={styles.optionsGrid}>
                {LOOKING_FOR_OPTIONS.map((option) => (
                  <TouchableOpacity
                    key={option.value}
                    style={[
                      styles.optionButton,
                      formData.lookingFor.includes(option.value) && styles.optionButtonSelected,
                    ]}
                    onPress={() => toggleLookingFor(option.value)}
                  >
                    <Text
                      style={[
                        styles.optionText,
                        formData.lookingFor.includes(option.value) && styles.optionTextSelected,
                      ]}
                    >
                      {option.label}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
              {errors.lookingFor && <Text style={styles.errorText}>{errors.lookingFor}</Text>}
            </View>

            {/* Optional Fields */}
            <Input
              label="Occupation"
              value={formData.occupation}
              onChangeText={(text) => setFormData(prev => ({ ...prev, occupation: text }))}
              placeholder="What do you do?"
              hint="Optional"
            />
          </View>
        </View>
        </ScrollView>

        {/* Fixed Bottom Button */}
        <View style={styles.footer}>
        <Button
          title="Continue"
          onPress={handleContinue}
          size="lg"
          fullWidth
          loading={loading}
        />
        </View>
      </SafeAreaView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  safeArea: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: Spacing.xl,
  },
  header: {
    paddingTop: Spacing.xl,
    paddingBottom: Spacing.lg,
  },
  title: {
    fontFamily: Typography.fonts.serif,
    fontSize: Typography.sizes['3xl'],
    fontWeight: Typography.weights.bold,
    color: Colors.light.text.primary,
    marginBottom: Spacing.xs,
  },
  subtitle: {
    fontFamily: Typography.fonts.sans,
    fontSize: Typography.sizes.base,
    color: Colors.light.text.secondary,
  },
  form: {
    gap: Spacing.lg,
    paddingBottom: Spacing.xl,
  },
  fieldGroup: {
    gap: Spacing.xs,
  },
  label: {
    fontSize: Typography.sizes.sm,
    fontFamily: Typography.fonts.sans,
    fontWeight: Typography.weights.medium,
    color: Colors.light.text.primary,
  },
  required: {
    color: Colors.light.error,
  },
  hint: {
    fontSize: Typography.sizes.xs,
    fontFamily: Typography.fonts.sans,
    color: Colors.light.text.secondary,
    marginBottom: Spacing.xs,
  },
  optionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: Spacing.sm,
  },
  optionButton: {
    paddingHorizontal: Spacing.lg,
    paddingVertical: Spacing.md,
    borderRadius: BorderRadius.md,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    backgroundColor: Colors.light.background,
  },
  optionButtonSelected: {
    borderColor: Colors.interactive.primary,
    backgroundColor: Colors.interactive.primary,
  },
  optionText: {
    fontSize: Typography.sizes.base,
    fontFamily: Typography.fonts.sans,
    fontWeight: Typography.weights.medium,
    color: Colors.light.text.primary,
  },
  optionTextSelected: {
    color: Colors.light.text.inverse,
  },
  errorText: {
    fontSize: Typography.sizes.xs,
    fontFamily: Typography.fonts.sans,
    color: Colors.light.error,
    marginTop: Spacing.xs,
  },
  datePickerButton: {
    paddingHorizontal: Spacing.lg,
    paddingVertical: Spacing.md,
    borderRadius: BorderRadius.md,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    backgroundColor: Colors.light.background,
    minHeight: 48,
    justifyContent: 'center',
  },
  datePickerButtonError: {
    borderColor: Colors.light.error,
  },
  datePickerText: {
    fontSize: Typography.sizes.base,
    fontFamily: Typography.fonts.sans,
    color: Colors.light.text.primary,
  },
  datePickerPlaceholder: {
    color: Colors.light.text.secondary,
  },
  ageDisplay: {
    fontSize: Typography.sizes.sm,
    fontFamily: Typography.fonts.sans,
    color: Colors.light.text.secondary,
    marginTop: Spacing.xs,
  },
  datePickerActions: {
    alignItems: 'center',
    paddingVertical: Spacing.md,
  },
  footer: {
    paddingHorizontal: Spacing.xl,
    paddingVertical: Spacing.lg,
    borderTopWidth: 1,
    borderTopColor: Colors.light.border,
  },
});
